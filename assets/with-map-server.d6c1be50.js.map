{"version":3,"file":"with-map-server.d6c1be50.js","sources":["../../../node_modules/@turf/destination/dist/es/index.js","../../../src/MapServerHandler.ts","../../../examples/with-map-server.ts"],"sourcesContent":["// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","import { default as turfDestination } from '@turf/destination';\nimport { default as turfDistance } from '@turf/distance';\n\nimport addIndoorTo from './addIndoorTo';\nimport IndoorMap from './IndoorMap';\nimport { bboxContains } from './Utils';\n\nimport type { MapGL, MapGLWithIndoor, IndoorMapOptions } from './Types';\nimport type { BBox } from 'geojson';\n\ntype RemoteMap = {\n    name: string,\n    path: string,\n    indoorMap?: IndoorMap\n}\n\nconst MIN_ZOOM_TO_DOWNLOAD = 17;\nconst AREA_TO_DOWNLOAD = 1000; // in terms of distance from user\n\nclass MapServerHandler {\n\n    serverUrl: string;\n\n    map: MapGLWithIndoor;\n    remoteMapsDownloaded: RemoteMap[];\n    downloadedBounds: BBox | null;\n\n    loadMapsPromise: Promise<void> = Promise.resolve();\n\n    indoorMapOptions?: IndoorMapOptions;\n\n    private constructor(serverUrl: string, map: MapGLWithIndoor, indoorMapOptions?: IndoorMapOptions) {\n        this.serverUrl = serverUrl;\n        this.map = map;\n        this.indoorMapOptions = indoorMapOptions;\n        this.remoteMapsDownloaded = [];\n        this.downloadedBounds = null;\n\n        if (map.loaded()) {\n            this.loadMapsIfNecessary();\n        } else {\n            map.on('load', () => this.loadMapsIfNecessary())\n        }\n        map.on('move', () => this.loadMapsIfNecessary());\n    }\n\n    private loadMapsIfNecessary = async () => {\n\n        if (this.map.getZoom() < MIN_ZOOM_TO_DOWNLOAD) {\n            return;\n        }\n\n        const viewPort = this.map.getBounds();\n        if (this.downloadedBounds !== null) {\n            if (bboxContains(this.downloadedBounds, viewPort.getNorthEast().toArray()) &&\n                bboxContains(this.downloadedBounds, viewPort.getSouthWest().toArray())) {\n                // Maps of the viewport have already been downloaded.\n                return;\n            }\n        }\n\n        const distanceEastWest = turfDistance(viewPort.getNorthEast().toArray(), viewPort.getNorthWest().toArray());\n        const distanceNorthSouth = turfDistance(viewPort.getNorthEast().toArray(), viewPort.getSouthEast().toArray());\n        // It is not necessary to compute others as we are at zoom >= 17, the approximation is enough.\n        const maxDistanceOnScreen = Math.max(distanceEastWest, distanceNorthSouth);\n        const bestSizeOfAreaToDownload = Math.max(AREA_TO_DOWNLOAD, maxDistanceOnScreen * 2);\n\n        const center = this.map.getCenter();\n        const dist = bestSizeOfAreaToDownload * Math.sqrt(2);\n        const northEast = turfDestination(center.toArray(), dist, Math.PI / 4).geometry.coordinates;\n        const southWest = turfDestination(center.toArray(), dist, - 3 * Math.PI / 4).geometry.coordinates;\n        const boundsToDownload = [southWest[1], southWest[0], northEast[1], northEast[0]] as BBox;\n\n        // TODO: I put this here because fetch is async and takes more time than the next call to loadMapsIfNecessary.\n        this.downloadedBounds = boundsToDownload;\n\n        await this.loadMapsPromise;\n        this.loadMapsPromise = this.loadMapsInBounds(boundsToDownload);\n    }\n\n    private loadMapsInBounds = async (bounds: BBox) => {\n        const url = this.serverUrl + `/maps-in-bounds/${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}`;\n        const maps: RemoteMap[] = await (await fetch(url)).json();\n\n        const mapsToRemove = this.remoteMapsDownloaded.reduce((acc: RemoteMap[], map) => {\n            if (!maps.find(_map => _map.path === map.path)) {\n                acc.push(map);\n            }\n            return acc;\n        }, []);\n\n        const mapsToAdd = maps.reduce((acc: RemoteMap[], map) => {\n            if (!this.remoteMapsDownloaded.find(_map => _map.path === map.path)) {\n                acc.push(map);\n            }\n            return acc;\n        }, []);\n\n        mapsToAdd.forEach(this.addCustomMap);\n        mapsToRemove.forEach(this.removeCustomMap);\n    };\n\n    private addCustomMap = async (map: RemoteMap) => {\n        const geojson = await (await fetch(this.serverUrl + map.path)).json();\n        map.indoorMap = IndoorMap.fromGeojson(geojson, this.indoorMapOptions);\n        this.map.indoor.addMap(map.indoorMap);\n        this.remoteMapsDownloaded.push(map);\n    };\n\n    private removeCustomMap = async (map: RemoteMap) => {\n        this.map.indoor.removeMap(map.indoorMap!);\n        this.remoteMapsDownloaded.splice(this.remoteMapsDownloaded.indexOf(map), 1);\n    }\n\n\n    static manage(server: string, map: MapGL, indoorMapOptions?: IndoorMapOptions) {\n        return new MapServerHandler(server, addIndoorTo(map), indoorMapOptions);\n    }\n\n}\n\nexport default MapServerHandler;\n","import { Map as MapboxMap } from 'mapbox-gl';\n\nimport accessToken from './mapbox-access-token';\nimport { IndoorControl, MapServerHandler } from '../src/index';\n\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport './style.css';\n\nconst app = document.querySelector<HTMLDivElement>('#app')!\n\nconst map = new MapboxMap({\n    container: app,\n    zoom: 18,\n    center: [2.3592843, 48.8767904],\n    style: 'mapbox://styles/mapbox/streets-v10',\n    accessToken,\n    hash: true\n});\n\n/**\n * Indoor specific\n */\nconst SERVER_URL = 'https://localhost:4001';\n\nconst indoorMapsOptions = {\n    beforeLayerId: 'housenum-label',\n    layersToHide: ['poi-scalerank4-l15', 'poi-scalerank4-l1', 'poi-scalerank3', 'road-label-small']\n}\n\nMapServerHandler.manage(SERVER_URL, map, indoorMapsOptions);\n\n// Add the specific control\nmap.addControl(new IndoorControl());\n"],"names":["destination","origin","distance","bearing","options","coordinates1","getCoord","longitude1","degreesToRadians","latitude1","bearingRad","radians","lengthToRadians","latitude2","longitude2","lng","radiansToDegrees","lat","point","MIN_ZOOM_TO_DOWNLOAD","AREA_TO_DOWNLOAD","MapServerHandler","serverUrl","map","indoorMapOptions","viewPort","bboxContains","distanceEastWest","turfDistance","distanceNorthSouth","maxDistanceOnScreen","bestSizeOfAreaToDownload","center","dist","northEast","turfDestination","southWest","boundsToDownload","bounds","url","maps","mapsToRemove","acc","_map","geojson","IndoorMap","server","addIndoorTo","app","MapboxMap","accessToken","SERVER_URL","indoorMapsOptions","IndoorControl"],"mappings":"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"}