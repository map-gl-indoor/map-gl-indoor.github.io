{"version":3,"file":"style.532636f9.js","sources":["../../../vite/modulepreload-polyfill","../../../src/IndoorControl.ts","../../../node_modules/@turf/helpers/dist/es/index.js","../../../node_modules/@turf/invariant/dist/es/index.js","../../../node_modules/@turf/distance/dist/es/index.js","../../../src/Utils.ts","../../../src/IndoorLayer.ts","../../../src/style/DefaultLayers.ts","../../../src/style/index.ts","../../../node_modules/@turf/meta/dist/es/index.js","../../../node_modules/@turf/bbox/dist/es/index.js","../../../src/GeojsonHelper.ts","../../../src/IndoorMap.ts","../../../src/addIndoorTo.ts"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","import IndoorLayer from './IndoorLayer';\nimport IndoorMap from './IndoorMap';\n\nimport type { Level, MapGL, MapGLWithIndoor } from './Types';\n\n/**\n * Creates a indoor control with floors buttons\n\n * @implements {IControl}\n */\nclass IndoorControl {\n\n    _map?: MapGLWithIndoor;\n    _indoor?: IndoorLayer;\n    _indoorMap: IndoorMap | null;\n\n    _container?: HTMLElement;\n    _levelsButtons: Array<HTMLElement>;\n    _selectedButton: HTMLElement | null;\n\n    constructor() {\n        this._levelsButtons = [];\n        this._selectedButton = null;\n        this._indoorMap = null;\n    }\n\n    onAdd(map: MapGL | MapGLWithIndoor) {\n\n        if ((map as any).indoor === undefined) {\n            throw Error('call addIndoorTo(map) before creating the IndoorControl');\n        }\n\n        this._map = map as MapGLWithIndoor;\n        this._indoor = this._map.indoor;\n\n        // Create container\n        const container = this._container = document.createElement(\"div\");\n        container.classList.add(\"mapboxgl-ctrl\");\n        container.classList.add(\"mapboxgl-ctrl-group\");\n        container.style.display = 'none';\n        container.addEventListener('contextmenu', this._onContextMenu);\n\n        // If indoor layer is already loaded, update levels\n        this._indoorMap = this._indoor.getSelectedMap();\n        if (this._indoor.getSelectedMap() !== null) {\n            this._updateNavigationBar()\n            this._setSelected(this._indoor.getLevel());\n        }\n\n        // Register to indoor events\n        this._map.on('indoor.map.loaded', this._onMapLoaded);\n        this._map.on('indoor.map.unloaded', this._onMapUnLoaded);\n        this._map.on('indoor.level.changed', this._onLevelChanged);\n\n        return container;\n    }\n\n    onRemove() {\n        this._container?.removeEventListener('contextmenu', this._onContextMenu);\n        this._container?.remove();\n        delete this._container;\n\n        this._map?.off('indoor.map.loaded', this._onMapLoaded);\n        this._map?.off('indoor.map.unloaded', this._onMapUnLoaded);\n        this._map?.off('indoor.level.changed', this._onLevelChanged);\n        delete this._map;\n    }\n\n    _onMapLoaded = ({ indoorMap }: { indoorMap: IndoorMap }): void => {\n        this._indoorMap = indoorMap;\n        this._updateNavigationBar();\n        this._setSelected(this._indoor!.getLevel());\n    }\n\n    _onMapUnLoaded = (): void => {\n        this._indoorMap = null;\n        this._updateNavigationBar();\n    }\n\n    _onLevelChanged = ({ level }: { level: Level | null }): void => this._setSelected(level);\n\n    _updateNavigationBar() {\n\n        if (!this._container) {\n            return;\n        }\n\n        if (this._indoorMap === null) {\n            this._container.style.display = 'none';\n            return;\n        }\n\n        this._container.style.display = 'block';\n\n        this._levelsButtons = [];\n        while (this._container.firstChild) {\n            this._container.removeChild(this._container.firstChild);\n        }\n\n        const range = this._indoorMap.levelsRange;\n        for (let i = range.max; i >= range.min; i--) {\n            this._levelsButtons[i] = this._createLevelButton(this._container, i);\n        }\n    }\n\n    _setSelected(level: Level | null) {\n\n        if (this._levelsButtons.length === 0) {\n            return;\n        }\n\n        if (this._selectedButton) {\n            this._selectedButton.style.fontWeight = \"normal\";\n        }\n        if (level !== null && this._levelsButtons[level]) {\n            this._levelsButtons[level].style.fontWeight = \"bold\";\n            this._selectedButton = this._levelsButtons[level];\n        }\n    }\n\n    _createLevelButton(container: HTMLElement, level: Level) {\n        const a = document.createElement(\"button\");\n        a.innerHTML = level.toString();\n        a.classList.add(\"mapboxgl-ctrl-icon\");\n        container.appendChild(a);\n        a.addEventListener('click', () => {\n            this._map?.fire('indoor.control.clicked', { level });\n            if (this._indoor!.getLevel() === level) return;\n            this._indoor!.setLevel(level);\n        });\n        return a;\n    }\n\n    _onContextMenu(e: Event) {\n        e.preventDefault();\n    }\n\n}\n\nexport default IndoorControl;\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","import type { ExpressionSpecification, Level } from './Types';\nimport type { BBox, Position } from 'geojson';\n\nexport const EarthRadius = 6371008.8;\n\nexport function overlap(bounds1: BBox, bounds2: BBox) {\n\n    // If one rectangle is on left side of other\n    if (bounds1[0] > bounds2[2] || bounds2[0] > bounds1[2]) {\n        return false;\n    }\n\n    // If one rectangle is above other\n    if (bounds1[3] < bounds2[1] || bounds2[3] < bounds1[1]) {\n        return false;\n    }\n\n    return true;\n}\n\nexport function filterWithLevel(initialFilter: ExpressionSpecification, level: Level, showFeaturesWithEmptyLevel: boolean = false): ExpressionSpecification {\n    return [\n        \"all\",\n        initialFilter,\n        [\n            'any',\n            showFeaturesWithEmptyLevel ? [\"!\", [\"has\", \"level\"]] : false,\n            [\n                'all',\n                [\n                    \"has\",\n                    \"level\"\n                ],\n                [\n                    \"any\",\n                    [\n                        \"==\",\n                        [\"get\", \"level\"],\n                        level.toString()\n                    ],\n                    [\n                        \"all\",\n                        [\n                            \"!=\",\n                            [\n                                \"index-of\",\n                                \";\",\n                                [\"get\", \"level\"]\n                            ],\n                            -1,\n                        ],\n                        [\n                            \">=\",\n                            level,\n                            [\n                                \"to-number\",\n                                [\n                                    \"slice\",\n                                    [\"get\", \"level\"],\n                                    0,\n                                    [\n                                        \"index-of\",\n                                        \";\",\n                                        [\"get\", \"level\"]\n                                    ]\n                                ]\n                            ]\n                        ],\n                        [\n                            \"<=\",\n                            level,\n                            [\n                                \"to-number\",\n                                [\n                                    \"slice\",\n                                    [\"get\", \"level\"],\n                                    [\n                                        \"+\",\n                                        [\n                                            \"index-of\",\n                                            \";\",\n                                            [\"get\", \"level\"]\n                                        ],\n                                        1\n                                    ]\n                                ]\n                            ]\n                        ]\n                    ]\n                ]\n            ]\n        ]\n    ];\n}\n\nexport function bboxCenter(bbox: BBox): Position {\n    const [west, south, east, north] = bbox;\n    return [(west + east) / 2, (south + north) / 2];\n}\n\nexport function bboxContains(bbox: BBox, point: Position): Boolean {\n    const [west, south, east, north] = bbox;\n    const [lng, lat] = point;\n\n    const containsLatitude = south <= lat && lat <= north;\n    let containsLongitude = west <= lng && lng <= east;\n    if (west > east) {\n        containsLongitude = west >= lng && lng >= east;\n    }\n\n    return containsLatitude && containsLongitude;\n}\n","import { default as turfDistance } from '@turf/distance';\nimport IndoorMap from './IndoorMap';\nimport { overlap, filterWithLevel, bboxCenter } from './Utils';\n\nimport type { Level, ExpressionSpecification, LayerSpecification, MapGL} from './Types';\nimport type { BBox } from 'geojson';\n\ntype SavedFilter = {\n    layerId: string,\n    filter: ExpressionSpecification\n}\n\nconst SOURCE_ID = 'indoor';\n\n/**\n * Manage indoor levels\n * @param {Map} map the Mapbox map\n */\nclass IndoorLayer {\n\n    _map: MapGL;\n    _level: Level | null;\n\n    _indoorMaps: Array<IndoorMap>;\n    _selectedMap: IndoorMap | null;\n    _previousSelectedMap: IndoorMap | null;\n    _previousSelectedLevel: Level | null;\n\n    _savedFilters: Array<SavedFilter>;\n    _mapLoadedPromise: Promise<void>;\n\n    _updateMapPromise: Promise<void>;\n\n    constructor(map: MapGL) {\n        this._map = map;\n        this._level = null;\n\n        this._indoorMaps = [];\n        this._savedFilters = [];\n        this._selectedMap = null;\n        this._previousSelectedMap = null;\n        this._previousSelectedLevel = null;\n        this._updateMapPromise = Promise.resolve();\n\n        if (this._map.loaded()) {\n            this._mapLoadedPromise = Promise.resolve();\n        } else {\n            this._mapLoadedPromise = new Promise(resolve => this._map.on('load', resolve));\n        }\n\n        this._map.on('moveend', () => this._updateSelectedMapIfNeeded());\n    }\n\n    getSelectedMap(): IndoorMap | null {\n        return this._selectedMap;\n    }\n\n    getLevel(): Level | null {\n        return this._level;\n    }\n\n    setLevel(level: Level | null, fireEvent: Boolean = true): void {\n\n        if (this._selectedMap === null) {\n            throw new Error('Cannot set level, no map has been selected');\n        }\n\n        this._level = level;\n        this._updateFiltering();\n        if (fireEvent) {\n            this._map.fire('indoor.level.changed', { level });\n        }\n    }\n\n    /**\n     * ***********************\n     * Handle level change\n     * ***********************\n     */\n\n    _addLayerForFiltering(layer: LayerSpecification, beforeLayerId?: string) {\n        this._map.addLayer(layer, beforeLayerId);\n        this._savedFilters.push({\n            layerId: layer.id,\n            filter: this._map.getFilter(layer.id) as ExpressionSpecification || [\"all\"]\n        });\n    }\n\n    addLayerForFiltering(layer: LayerSpecification, beforeLayerId?: string) {\n        this._addLayerForFiltering(layer, beforeLayerId);\n        this._updateFiltering();\n    }\n\n    _removeLayerForFiltering(layerId: string) {\n        this._savedFilters = this._savedFilters.filter(({ layerId: id }) => layerId !== id);\n        this._map.removeLayer(layerId);\n    }\n\n    removeLayerForFiltering(layerId: string) {\n        this._removeLayerForFiltering(layerId);\n        this._updateFiltering();\n    }\n\n    _updateFiltering() {\n        const level = this._level;\n\n        let filterFn: (filter: ExpressionSpecification) => ExpressionSpecification;\n        if (level !== null) {\n            const showFeaturesWithEmptyLevel = this._selectedMap ? this._selectedMap.showFeaturesWithEmptyLevel : false;\n            filterFn = (filter: ExpressionSpecification) => filterWithLevel(filter, level, showFeaturesWithEmptyLevel);\n        } else {\n            filterFn = (filter: ExpressionSpecification): ExpressionSpecification => filter;\n        }\n\n        this._savedFilters.forEach(({ layerId, filter }) => {\n            this._map.setFilter(layerId, filterFn(filter))\n        });\n    }\n\n\n\n    /**\n     * **************\n     * Handle maps\n     * **************\n     */\n\n    async addMap(map: IndoorMap) {\n        this._indoorMaps.push(map);\n        await this._updateSelectedMapIfNeeded();\n    }\n\n    async removeMap(map: IndoorMap) {\n        this._indoorMaps = this._indoorMaps.filter(_indoorMap => _indoorMap !== map);\n        await this._updateSelectedMapIfNeeded();\n    }\n\n\n    async _updateSelectedMapIfNeeded() {\n\n        await this._mapLoadedPromise;\n\n        // Avoid to call \"closestMap\" or \"updateSelectedMap\" if the previous call is not finished yet\n        await this._updateMapPromise;\n        this._updateMapPromise = (async () => {\n            const closestMap = this._closestMap();\n            if (closestMap !== this._selectedMap) {\n                this._updateSelectedMap(closestMap);\n            }\n        })();\n        await this._updateMapPromise;\n    }\n\n    _updateSelectedMap(indoorMap: IndoorMap | null) {\n\n        const previousMap = this._selectedMap;\n\n        // Remove the previous selected map if it exists\n        if (previousMap !== null) {\n            previousMap.layersToHide.forEach(layerId => this._map.setLayoutProperty(layerId, 'visibility', 'visible'));\n            previousMap.layers.forEach(({ id }) => this._removeLayerForFiltering(id));\n            this._map.removeSource(SOURCE_ID);\n\n            if (!indoorMap) {\n                // Save the previous map level.\n                // It enables the user to exit and re-enter, keeping the same level shown.\n                this._previousSelectedLevel = this._level;\n                this._previousSelectedMap = previousMap;\n            }\n\n            this.setLevel(null, false);\n            this._map.fire('indoor.map.unloaded', { indoorMap: previousMap });\n        }\n\n        this._selectedMap = indoorMap;\n        if (!indoorMap) {\n            return;\n        }\n\n        const { geojson, layers, levelsRange, beforeLayerId } = indoorMap;\n\n        // Add map source\n        this._map.addSource(SOURCE_ID, {\n            type: \"geojson\",\n            data: geojson\n        });\n\n        // Add layers and save filters\n        layers.forEach(layer => this._addLayerForFiltering(layer, beforeLayerId));\n\n        // Hide layers which can overlap for rendering\n        indoorMap.layersToHide.forEach(layerId => this._map.setLayoutProperty(layerId, 'visibility', 'none'));\n\n        // Restore the same level when the previous selected map is the same.\n        const level = this._previousSelectedMap === indoorMap\n            ? this._previousSelectedLevel\n            : Math.max(Math.min(indoorMap.defaultLevel, levelsRange.max), levelsRange.min)\n\n        this.setLevel(level, false);\n\n        this._map.fire('indoor.map.loaded', { indoorMap });\n    }\n\n    _closestMap() {\n\n        // TODO enhance this condition\n        if (this._map.getZoom() < 17) {\n            return null;\n        }\n\n        const cameraBounds = this._map.getBounds();\n        const cameraBoundsTurf = [\n            cameraBounds.getWest(), \n            cameraBounds.getSouth(), \n            cameraBounds.getEast(), \n            cameraBounds.getNorth()\n        ] as BBox;\n        const mapsInBounds = this._indoorMaps.filter(indoorMap =>\n            overlap(indoorMap.bounds, cameraBoundsTurf)\n        );\n\n        if (mapsInBounds.length === 0) {\n            return null;\n        }\n\n        if (mapsInBounds.length === 1) {\n            return mapsInBounds[0];\n        }\n\n        /*\n         * If there is multiple maps at this step, select the closest\n         */\n        let minDist = Number.POSITIVE_INFINITY;\n        let closestMap = mapsInBounds[0];\n        for (const map of mapsInBounds) {\n            const _dist = turfDistance(bboxCenter(map.bounds), bboxCenter(cameraBoundsTurf));\n            if (_dist < minDist) {\n                closestMap = map;\n                minDist = _dist;\n            }\n        }\n        return closestMap;\n    }\n\n}\n\nexport default IndoorLayer;\n","import defaultLayers from './default_layers.json';\n\nimport type { LayerSpecification } from '../Types';\n\nlet layers: Array<LayerSpecification> = defaultLayers;\n\n/**\n * Transform the generic \"poi-indoor\" layer into multiple layers using filters based on OSM tags\n */\n\nconst POI_LAYER_ID = \"poi-indoor\";\n\ntype FilterMakiEntry = {\n    filter: any,\n    maki: string\n}\n\nconst OSM_FILTER_MAPBOX_MAKI_LIST: FilterMakiEntry[] = [\n    {\n        filter: ['filter-==', 'amenity', 'fast_food'],\n        maki: 'fast-food'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'restaurant'],\n        maki: 'restaurant'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'cafe'],\n        maki: 'cafe'\n    },\n    {\n        filter: ['filter-in-small', 'amenity', ['literal', ['bank', 'vending_machine']]],\n        maki: 'bank'\n    },\n    {\n        filter: ['filter-==', 'amenity', 'toilets'],\n        maki: 'toilet'\n    },\n    {\n        filter: ['any', ['filter-==', 'highway', 'elevator'], ['has', 'elevator']],\n        maki: 'triangle-stroked'\n    },\n    {\n        filter: ['filter-==', 'natural', 'tree'],\n        maki: 'park'\n    },\n    {\n        filter: ['filter-==', 'shop', 'travel_agency'],\n        maki: 'suitcase'\n    },\n    {\n        filter: ['filter-==', 'shop', 'convenience'],\n        maki: 'grocery'\n    },\n    {\n        filter: ['filter-==', 'shop', 'bakery'],\n        maki: 'bakery'\n    },\n    {\n        filter: ['filter-==', 'shop', 'chemist'],\n        maki: 'pharmacy'\n    },\n    {\n        filter: ['filter-==', 'shop', 'clothes'],\n        maki: 'clothing-store'\n    },\n    {\n        filter: ['filter-==', 'highway', 'steps'],\n        maki: 'entrance'\n    }\n];\n\nfunction createPoiLayers(metaLayer: LayerSpecification): Array<LayerSpecification> {\n\n    const otherShopsEntry =\n    {\n        filter:\n            ['all',\n                ['has', 'shop'],\n                ['!',\n                    [\n                        \"filter-in-small\",\n                        \"shop\",\n                        [\n                            \"literal\",\n                            OSM_FILTER_MAPBOX_MAKI_LIST\n                                .filter(val => val.filter[1] === 'shop')\n                                .map(val => val.filter[2])\n                        ]\n                    ]\n                ]\n            ],\n        maki: 'shop'\n    };\n\n    return OSM_FILTER_MAPBOX_MAKI_LIST\n        .concat(otherShopsEntry)\n        .map(poi => {\n            const newLayer = Object.assign({}, metaLayer);\n            newLayer.id += `-${poi.maki}`;\n            newLayer.filter = poi.filter;\n            newLayer.layout = Object.assign({}, metaLayer.layout);\n            newLayer.layout['icon-image'] = `${poi.maki}-15`;\n            return newLayer;\n        });\n}\n\nconst poiLayer = layers.find(layer => layer.id === POI_LAYER_ID);\nif (poiLayer) {\n    // Convert poi-indoor layer into several poi-layers\n    createPoiLayers(poiLayer).forEach(_layer => layers.push(_layer));\n    layers = layers.filter(layer => layer.id !== POI_LAYER_ID);\n}\n\nexport default layers;\n","import DefaultLayers from './DefaultLayers';\n\nexport default { DefaultLayers };\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import bbox from '@turf/bbox';\n\nimport type { BBox, Feature } from 'geojson';\nimport type { LevelsRange, IndoorMapGeoJSON } from './Types';\n\n/**\n * Helper for Geojson data\n */\nclass GeoJsonHelper {\n\n    /**\n     * Extract level from feature\n     *\n     * @param {GeoJSONFeature} feature geojson feature\n     * @returns {LevelsRange | number | null} the level or the range of level.\n     */\n    static extractLevelFromFeature(feature: Feature): (LevelsRange | number | null) {\n        if (!!feature.properties &&\n            feature.properties.level !== null) {\n            const propertyLevel = feature.properties['level'];\n            if (typeof propertyLevel === 'string') {\n                const splitLevel = propertyLevel.split(';');\n                if (splitLevel.length === 1) {\n                    const level = parseFloat(propertyLevel);\n                    if (!isNaN(level)) {\n                        return level;\n                    }\n                } else if (splitLevel.length === 2) {\n                    const level1 = parseFloat(splitLevel[0]);\n                    const level2 = parseFloat(splitLevel[1]);\n                    if (!isNaN(level1) && !isNaN(level2)) {\n                        return {\n                            min: Math.min(level1, level2),\n                            max: Math.max(level1, level2)\n                        };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract levels range and bounds from geojson\n     *\n     * @param {IndoorMapGeoJSON} geojson the geojson\n     * @returns {Object} the levels range and bounds.\n     */\n    static extractLevelsRangeAndBounds(geojson: IndoorMapGeoJSON)\n        : ({ levelsRange: LevelsRange, bounds: BBox }) {\n\n        let minLevel = Infinity;\n        let maxLevel = -Infinity;\n\n        const bounds = bbox(geojson);\n\n        const parseFeature = (feature: Feature): void => {\n            const level = this.extractLevelFromFeature(feature);\n            if (level === null) {\n                return;\n            }\n            if (typeof level === 'number') {\n                minLevel = Math.min(minLevel, level);\n                maxLevel = Math.max(maxLevel, level);\n            } else if (typeof level === 'object') {\n                minLevel = Math.min(minLevel, level.min);\n                maxLevel = Math.max(maxLevel, level.max);\n            }\n        };\n\n        if (geojson.type === 'FeatureCollection') {\n            geojson.features.forEach(parseFeature);\n        }\n\n        if (minLevel === Infinity || maxLevel === -Infinity) {\n            throw new Error('No level found');\n        }\n        return {\n            levelsRange: { min: minLevel, max: maxLevel },\n            bounds\n        };\n    }\n}\nexport default GeoJsonHelper;\n","import Style from './style';\nimport GeoJsonHelper from './GeojsonHelper';\n\n\nimport type { LevelsRange, IndoorMapGeoJSON, IndoorMapOptions, LayerSpecification } from './Types';\nimport type { BBox } from 'geojson';\n\nclass IndoorMap {\n    bounds: BBox;\n    geojson: IndoorMapGeoJSON;\n    layers: Array<LayerSpecification>;\n    levelsRange: LevelsRange;\n    beforeLayerId?: string;\n    layersToHide: Array<string>;\n    defaultLevel: number;\n    showFeaturesWithEmptyLevel: boolean;\n\n    constructor(bounds: BBox,\n        geojson: IndoorMapGeoJSON,\n        layers: Array<LayerSpecification>,\n        levelsRange: LevelsRange,\n        layersToHide: Array<string>,\n        defaultLevel: number,\n        showFeaturesWithEmptyLevel: boolean,\n        beforeLayerId?: string\n    ) {\n\n        this.bounds = bounds;\n        this.geojson = geojson;\n        this.layers = layers;\n        this.levelsRange = levelsRange;\n        this.layersToHide = layersToHide;\n        this.defaultLevel = defaultLevel;\n        this.showFeaturesWithEmptyLevel = showFeaturesWithEmptyLevel;\n        this.beforeLayerId = beforeLayerId;\n\n    }\n\n    static fromGeojson(geojson: IndoorMapGeoJSON, options: IndoorMapOptions = {}) {\n\n        const { bounds, levelsRange } = GeoJsonHelper.extractLevelsRangeAndBounds(geojson);\n\n        const map = new IndoorMap(\n            bounds,\n            geojson,\n            options.layers ? options.layers : Style.DefaultLayers,\n            levelsRange,\n            options.layersToHide ? options.layersToHide : [],\n            options.defaultLevel ? options.defaultLevel : 0,\n            options.showFeaturesWithEmptyLevel ? options.showFeaturesWithEmptyLevel : false,\n            options.beforeLayerId);\n\n        return map;\n    }\n}\n\nexport default IndoorMap;\n","import IndoorLayer from './IndoorLayer';\n\nimport type { MapGLWithIndoor, MapGL } from './Types';\n\nexport default function addIndoorTo(map: MapGL): MapGLWithIndoor {\n    Object.defineProperty(\n        map,\n        'indoor',\n        {\n            get: function () {\n                if (!this._indoor) {\n                    this._indoor = new IndoorLayer(this);\n                }\n                return this._indoor;\n            }\n        });\n\n    return map as MapGLWithIndoor;\n}\n"],"names":["relList","link","processPreload","mutations","mutation","node","getFetchOpts","script","fetchOpts","IndoorControl","map","container","indoorMap","level","range","i","a","earthRadius","factors","feature","geom","properties","options","feat","point","coordinates","isNumber","radiansToLength","radians","units","factor","lengthToRadians","distance","radiansToDegrees","degrees","degreesToRadians","num","getCoord","coord","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","overlap","bounds1","bounds2","filterWithLevel","initialFilter","showFeaturesWithEmptyLevel","bboxCenter","bbox","west","south","east","north","bboxContains","lng","lat","containsLatitude","containsLongitude","SOURCE_ID","IndoorLayer","resolve","fireEvent","layer","beforeLayerId","layerId","id","filterFn","filter","_indoorMap","closestMap","previousMap","geojson","layers","levelsRange","cameraBounds","cameraBoundsTurf","mapsInBounds","minDist","_dist","turfDistance","defaultLayers","POI_LAYER_ID","OSM_FILTER_MAPBOX_MAKI_LIST","createPoiLayers","metaLayer","otherShopsEntry","val","poi","newLayer","poiLayer","_layer","DefaultLayers","Style","coordEach","callback","excludeWrapCoord","j","k","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","result","GeoJsonHelper","propertyLevel","splitLevel","level1","level2","minLevel","maxLevel","bounds","parseFeature","IndoorMap","layersToHide","defaultLevel","addIndoorTo"],"mappings":"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"}